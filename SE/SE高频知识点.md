# SE高频



## JAVA 基础

### P1:  泛型

* 概述:
    * 泛型本质是参数化类型,解决不确定对象具体类型的问题.
    * 泛型在定义处只具备执行Object方法的能力.
* 优点:
    * 类型安全,放置什么类型,取出来就是什么类型,不存在ClassCastException类型转换异常;
    * 提升可读性,编码阶段就显式地知道泛型集合,泛型方法等处理的对象类型.
    * 代码重用,合并了用类型的处理代码;
* **泛型擦除:**
    * 泛型用于编译阶段,编译后的字节码文件不包含泛型类型信息,因为虚拟机没有泛型类型对象,所有对象都属于普通类.
        * 例如:List<Object>或List<String>,在编译后都会变成list;
    * 定义一个泛型类型,会自动提供一个对应原始类型,类型变量会被擦除;
        * 如果没有限定类型就会替换为Object,如果有限定类型就会替换为第一个限定类型;
            * 例如:<T extends A & B> 会使用A类型替换T.



### P2:  反射

* **概述:(什么是反射?)**
  * 是指在运行状态中,对于任意一个类,都能够**知道**这个类的所有属性和方法;对于任意一个对象,都能够**调用**它的任意一个属性和方法.通俗的讲,就是在得到class对象之后,反向获取该对象的各种信息
  * 前提条件:想要解剖一个类,必须要先获取到该类的字节码文件对象.
* **功能,作用:**
  * 在运行时判断任意一个对象所属的类;
  * 在运行时构造任意一个类的对象;
  * 在运行时判断任意一个类所具有的成员变量和方法;
  * 在运行时调用任意对象的方法
* **哪里用到了反射?**
  * 框架中:
  * 加载驱动:
  * 读取配置文件;
* **优缺点:**
  * 优点:提高了程序的灵活性和扩展性,降低耦合性,提高自适应能力;
  * 缺点:
    * 性能问题:
      * 反射基本上是一种解释操作,用于字段和方法接入时要远慢于直接代码.因此反射机制主要用于在灵活性和扩展性要求很高的系统框架上,普通的程序不建议使用.
    * 反射会模糊程序的内部逻辑:
      * 程序员希望能在源代码中看到程序的逻辑,反射则绕过了源代码,因而会带来维护的问题,反射代码比相应的直接直接代码更复杂.

**6）如何使用java的反射?**

    * 通过一个全限类名创建一个对象
        * Class.forName(“全限类名”); 例如：com.mysql.jdbc.Driver Driver类已经被加载到 jvm中，并且完成了类的初始化工作就行了
        * 类名.class; 获取Class<？> clz 对象
        * 对象.getClass();
    * 获取构造器对象，通过构造器new出一个对象
        * Clazz.getConstructor([String.class]);
        * Con.newInstance([参数]);
    * 通过class对象创建一个实例对象（就相当与new类名（）无参构造器)
        * Clazz.newInstance();
    * 通过class对象获得一个属性对象
        * Field c=clz.getFields()：获得某个类的所有的公共（public）的字段，包括父类中的字段。
        * Field c=clz.getDeclaredFields()：获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段 e.
    * 通过class对象获得一个方法对象
        * Clazz.getMethod(“方法名”,class……parameaType);（只能获取公共的）
        * Clazz.getDeclareMethod(“方法名”);（获取任意修饰的方法，不能执行私有）
        * M.setAccessible(true);（让私有的方法可以执行）
    * f. 让方法执行
        * Method.invoke(obj实例对象,obj可变参数);-----（是有返回值的）





### JAVA 8 新特性:

- **lambda 表达式:**
  - lambda表达式允许把函数作为一个方法的参数传递到方法中,主要用来简化匿名内部类的代码;
- 















